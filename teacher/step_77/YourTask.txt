Знакомство с принципом DRY.

Принцип DRY, или "Don't Repeat Yourself" (Не повторяйся), — это одно из ключевых
руководств в программировании, направленное на сокращение повторения информации.

Основная идея заключается в том, чтобы минимизировать дублирование кода путём
абстрагирования общих задач в единую структуру данных или код, что улучшает
читаемость и обслуживаемость программы.

Принцип DRY предполагает, что каждый кусок знаний должен иметь единственное,
несомненное и авторитетное представление в системе. Это означает, что информация
не должна быть повторена в разных частях приложения, поскольку каждое дублирование
увеличивает возможность ошибок и затрудняет последующие изменения.

Применение принципа DRY может проявляться в следующем:

1. **Использование функций и методов**: Создавайте функции и методы для
выполнения повторяющихся задач, чтобы код не дублировался в разных местах программы.

2. **Классы и наследование**: Используйте объектно-ориентированные концепции,
такие как классы и наследование, чтобы общий код был в базовом классе,
а специфичный для производных классов — в наследниках.

3. **Конфигурационные файлы**: Храните параметры конфигурации,
которые используются в разных частях приложения, в централизованных конфигурационных файлах.

4. **Шаблоны и компоненты**: В веб-разработке и разработке пользовательских интерфейсов
используйте шаблоны или компоненты для стандартных элементов интерфейса, таких как кнопки, меню и формы.

Применение принципа DRY уменьшает вероятность ошибок и упрощает процесс обновления
и поддержки программного обеспечения, поскольку изменения нужно вносить только в одном месте,
а не во множестве повторяющихся блоков кода.


Ментор обратил ваше внимание на то, что после перевода системы
на коды ошибок в коде осталось много повторений. Это касается
кода создания экземпляров класса ValidationError:

    private ValidationError buildError(String errorCode) {
        String errorDescription = errorCodeUtil.getErrorDescription(errorCode);
        return new ValidationError(errorCode, errorDescription);
    }

Ментор предлагает вынести этот кусочек кода в класс
ValidationErrorFactory, повесить на него аннотацию @Component
и воспользоваться этим классом во всех местах программы
где нужно создавать экземпляр класса ошибки.


Ваша задача: реализовать предложение ментора.


Совет: в этом задании нужно сделать много изменений.
Код, который дублируется расположен в большом количестве классов.
Не старайтесь сделать все изменения одним большим куском.
Попробуйте разбить все необходимые изменения на маленькие подзадачи.

Чем меньше будет подзадача, тем быстрее вы с ней справитесь!

Делать большие изменения в коде проще, надежнее
и быстрее маленькими шагами, маленькими итерациями!

Примерный план реализации требований может выглядеть так:
- создать новый класс ValidationErrorFactory;
- скопировать в него общую логику;
- сделать этот класс компонентом;

- найти в коде первый класс где есть повторяющаяся логика;
- воспользоваться новым классом и удалить повторяющийся код;
- запустить тесты - они упадут так как код класса поменялся;
- исправить упавшие тесты;
- запустить тесты еще раз - убедиться что они все проходят;

- найти в коде следующий класс где есть повторяющаяся логика;
- повторить для него действия выше.

И так до тех пор, пока не будут внесены все изменения в код.

Работа с кодом это инкрементальный, итерационный процесс!

На каждом шаге программисты улучшают код или расширяют его функциональность.

Любые изменения в коде лучше делать маленькими шагами!

Программист как художник, который чистый холст маленькими шагами
превращает в произведение искусства.

Нельзя сделать большую задачу хорошо и качественно за один раз.

Большие задачи решаются и качественные проекты создаются маленькими,
инкрементальными изменениями, вносимыми в код проекта на регулярной основе!

PS: не забудьте по окончанию выполнения шага создать и заполнить
файл /documentation/Step_X_description.txt. Формат заполнения этого
файла описан в step_1 в файле Learning_reflection.txt.